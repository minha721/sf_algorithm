## 15170_낚시터자리잡기
1. 입력 받은 출입구 위치와 낚시꾼수를 (출입구위치-1, 낚시꾼수)로 묶어 리스트에 저장
2. 1에서 만든 리스트를 순열로 구해서 순서를 구함
3. 순열별로 solve 함수 돌려서 최소값 구함

#### solve 함수
1. 현재 몇번째 게이트인지에 따라 위치와 낚시꾼의 수를 받아온다
2. 만약 depth가 낚시꾼의 수와 같다면<br>
2-1. idx가 2라면(즉, 마지막 게이트라면) 현재의 최솟값과 dis를 비교하고 리턴<br>
   
2-2. 2가 아니라면 다음 게이트 확인<br>

3. depth가 낚시꾼의 수와 같지 않다면
4. N번 반목문을 돌며 현재 위치에서 가까운 순서대로 확인<br>
4-1. 마지막 낚시꾼을 확인 할 때는 현재 위치에서 i만큼 떨어진 자리가 양쪽에 모두 가능하면 양쪽에 대해 백트래킹 후 break<br>
   
4-2. 마지막 낚시꾼이 아니라면 현재 위치에서 i만큼 떨어진 자리가 양쪽에 모두 가능해도 한쪽에 대해서만 백트래킹 후 break<br>

4-3. 왼쪽과 오른쪽 각각 백트래킹하는거 함수로 빼고 싶었는데.. 알 수 없는 오류가 나서 일단은 뒀습니다..

## 15172_헌터
1. permutation : 순열 직접 구하는 함수 응용해서 i번 몬스터를 잡아야 i번째 클라이언트로 갈 수 있는 모든 경우의 수를 구한다
2. 이 경우의 수 각각에 대해 이동 거리를 구하며 최솟값을 갱신

## 15173_Shuffle-O-Matic
1. 정렬된 카드 비교를 위해 오름차순, 내림차순으로 정렬한 함수를 csa, csd에 저장
2. dfs 함수 실행

#### dfs 함수
1. 섞는 횟수가 5번 초과이거나, 현재 최솟값보다 크다면 리턴
2. 카드가 정렬됐다면 현재 최솟값과 비교 후 리턴
3. 1, 2에 걸리지 않았다면 0~N-1 다이얼로 카드 셔플한 것과 cnt 증가 시켜서 재귀함수

#### shffle 함수
1. dial 번호의 다이얼로 card를 섞어서 리턴하는 함수
![IMG_EC5FD0C35C01-1](https://user-images.githubusercontent.com/49333608/187067976-ccf3bb5b-7f43-41b1-8bdd-cfb827635877.jpeg)